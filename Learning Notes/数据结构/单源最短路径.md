# 1 Dijkstra算法
## 1.1 算法步骤
- 刚开始，初始节点的距离预估值为0，其他节点的距离预估值为 $\infty$
- 取所有节点中<font color=red>距离预估值最小</font>且<font color=red>未被访问</font>的一个节点
- 访问它所有<font color=red>未被访问</font>的邻接节点，并更新其邻接节点的距离预估值（**单步收敛操作**）
- 设定该节点为已访问
- 重复以上操作，直到所有节点均被访问

## 1.2 算法复杂度
$$
|V| \times\{T(\text { FindMin })+T(\text { ExtractMin })\}+|E| \times T(\text { UpdateKey })
$$
若采用 Fibonacci 堆，算法复杂度最低，为 $O(n\log(n)+m)$

## 1.3 优缺点
- 算法性能很高
- 只适用于权重非负图
- 如果有些边的权重变了，需重新计算最短路径

# 2 Bellman-Ford 算法
## 2.1 算法步骤
- 刚开始，初始节点的距离预估值为0，其他节点的距离预估值为 $\infty$
- 遍历所有的边，并更新距离预估值变小的节点（**单步收敛操作**）
- 以上操作执行 $n$ 遍，$n$ 为节点数 $|V|$

## 2.2 算法复杂度
总共的遍历个数为 $m(n-1)$，因此算法复杂度为 $$O(nm)$$

## 2.3 优缺点
- 速度稍慢
- 可以处理负边

# 3 DAG最短路径算法
## 3.1 算法步骤
- 设定初始节点距离预估值为0，其他节点的距离预估值为 $\infty$
- 按照[[拓扑排序]]的顺序依次访问各个节点，访问节点所有的邻接节点并更新其距离预估值

# 4 算法复杂度比较
![](https://obsdian-img-1319433252.cos.ap-shanghai.myqcloud.com/PixPin_2023-12-24_11-01-58.png)