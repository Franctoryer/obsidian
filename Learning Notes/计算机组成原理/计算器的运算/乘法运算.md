# 1 原码一位乘

## 1.1 计算步骤


1. 被乘数的最后一位乘以乘数的最后一位，得到部分积
2. 部分积向右移位（逻辑右移），部分积的最后一位作为乘数的第一位（加几次就移几次）
3. 循环往复

<font color = orange>注：符号位单独处理，做异或运算</font>

## 1.2 硬件实现
在硬件方面，需要：
- 3个寄存器，其中两个具有移位功能（X 保存被乘数，ACC 保存乘积高位，MQ 保存乘数和乘积低位）
- 1个全加器

![](https://obsdian-img-1319433252.cos.ap-shanghai.myqcloud.com/yuanmayiweicheng.jpg)

- A 是 ACC，保存部分积的高位，Q 是 MQ (乘商寄存器)
- S 保存符号位，A 和 Q 只保存数值部分
- 计数器计算移位次数，当移位次数减为0，计算结束

> 为什么以移位操作评判计算的结束？因为乘数位是0时可以不做加法运算


# 2 原码二位乘


# 3 补码一位乘

加一个辅助位，第一个辅助位为0.

|$y_iy_{i+1}$|操作|
|:-:|:-:|
|0 0|右移一位|
|0 1|部分积加 $[x]_{补}$，再右移一位|
|1 0|部分积加 $[-x]_{补}$，再右移一位|
|1 1|右移一位|

<font color = orange>乘数的符号位也要写进去</font> 
